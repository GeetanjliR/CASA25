[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CASA00025 : Comprehensive Multi-Disaster Application",
    "section": "",
    "text": "Spatial events are complex and often entail chain reactions. Moreover, severe ripple effects can be observed, especially during disasters in densely populated urban areas. It becomes imperative to understand such disaster events collectively to comprehend the domino effect and its implications. Thus, the project aims to create an application to assess multiple disaster events.\n\n\n\nApplication Overview\n\n\n\n\nWith increasing anthropological interference with nature and non-environmentally friendly development, the risk of disasters across the globe is on the rise. The present body of knowledge witnesses that disaster events are often studied in silos. However, recent evidence from Japan shows that more than one disaster can occur simultaneously, such as earthquakes, tsunamis, fires, and landslides. On January 1st, 2024, an earthquake with a magnitude of 7.5 hit the Noto Peninsula, Japan, resulting in an estimated 10,000 buildings damaged or destroyed. The extent and intensity of the disaster in the Noto Peninsula, which consists of 300-400 meter mountains and elevations, presents varying geographic conditions, embedding a multi-nature of land-forms and its events, making it difficult to assess the multi-disaster occurrence together or as a chain of activities. In order to identify the overlapping extent and intensity of the multiple-disaster impact, the attempted application seeks to estimate spatial and physical implications using satellite imagery. Therefore, a multi-disaster map layer could provide the extent of spatial severity and impact to assess various areas and building-level and area-level measures. Thus, the complex urban system requires a comprehensive assessment tool.\n\n\n\nVarious stakeholders have been identified who can benefit from the application. The Japan Ministry of Disaster Management is one such stakeholder that could use the application to assess the typology of disasters, whether individually or comprehensively. Understanding the disasters holistically, the housing department may utilize the application to carry out suitable building retrofitting or renovation. Additionally, appropriate beneficiary schemes may use the application to provide compensation. Furthermore, the Ministry of Land, Infrastructure, Transport, and Tourism could further analyze the epicenter from individual disaster and combined disaster event scenarios. Thus, Ishikawa Prefecture (Local Authority) and reconstruction agencies are also relevant stakeholders. Studies, research, and reports on building investigation (e.g., material and years), level of damage could be conducted, aiding in policy interventions such as the review of the Building Standards Act. Beneficiary schemes (e.g., compensation) or reconstruction for Future Urban Planning, as well as for immediate rescue and search bots, may also benefit from the application.\n\n\n\nData-driven assessment and decision-making application could provide ease of interaction for users to understand and action upon. In order to handle ginormous datasets to plan and manage complex spatial phenomena for above identified stakeholders could be enabled by create a user interface to disseminate information and knowledge. Thus, Sentinel-1 Synthetic Aperture Radar (SAR) imagery, Sentinel-1 GRD imagery for earthquake, USGS SRTMGL1 imagery for Tsunami, MODIS/061/MCD64A1 for fire and COPERNICUS/S1_GRD for landslide satellite data are significant to the study.\n\n\n\nA robust methodology has been employed to achieve the aim of designing an application to assess the impact of multiple disaster events in a given spatial location in Japan. The first objective involves designing maps for individual disasters, such as earthquakes, tsunamis, fires, and landslides. Subsequently, the multi-disaster map depicts the intensity of disasters in terms of the number of events affecting the same building or area. This exercise aims to design an application to assess the impact of multiple disaster events in a given spatial location of the City of Wajima. The present design of the application attempts to achieve the following objectives:\n\nTo understand the intensity of the disaster in terms of the number/ level of disasters impacting building damage or spatial vulnerability.\nFinally, to develop a user interface application for the ease of information access and knowledge dissemination to stakeholders.\n\nThe various methods used are machine learning (ML) using Random Forest, NDVI/NIR, confusion matrix, T-Test, mean, standard deviation, confidence level, assumptions, standards. In addition, these objectives facilitate the development of an application for easy of access to information and dissemination of knowledge to users whose methodology is as below.\n\n\n\nMethodology\n\n\n\n\n\nCreating a user-friendly interactive platform, the multi-disaster application offers several advantages. The present application categorizes into sequential disaster maps of earthquakes, landslides, fires, and tsunamis, each equipped with layers, panels, buttons, sliders, etc., for user interaction. The earthquake map provides building damage visualization, allowing users to draw polygons to calculate the number of damaged buildings and shows damage assessment using a low-to-high scale based on t-test results. The landslide map visualizes occurrences of landslides and allows users to assess intensity by toggling between options such as pre-event, post-event, landslide detection, road, water bodies using the confusion matrix, and accuracy algorithm. Similarly, the fire disaster map illustrates the catchment area from the fire source, with layers based on brightness and surface temperature change for further interaction. Lastly, the tsunami disaster map displays building damage and flood level implications, allowing users to adjust the flood level slider to identify inundated buildings and area. Overall, the designed interface offers multi-disaster maps with various options for user interaction to assess location, building damage count, risk levels, pre-event/post-event scenarios, buffer zones, catchment areas, and more.Therefore, the outputs could be utilized by the user, i.e., identified stakeholders, to undertake building reconstruction, retrofitting, policy interventions, disaster mitigation, and management.\n\n\n\n\nThe following link to application is as below.\n\n\n\n\n\n\n\n\n\nThe provided JavaScript code defines a function ‘ttest’ for performing a t-test analysis on Sentinel-1 Synthetic Aperture Radar (SAR) imagery. The function takes inputs such as the image collection ‘s1’, shock date, pre-event and post-event intervals, and calculates the t-value representing the magnitude of change between the two periods. It computes the mean and standard deviation for both the pre-event and post-event periods, then calculates the pooled standard deviation and the denominator of the t-test formula. Finally, it returns the absolute value of the change, which indicates the significance of the difference between the two periods.\nAdditionally, there is another function ‘filter_s1’ that filters Sentinel-1 GRD (Ground Range Detected) imagery based on specified parameters such as orbit path, polarization, and date range. It aggregates the relative orbit numbers, then maps over each orbit to filter the image collection accordingly. Within this function, the ‘ttest’ function is applied to both VV and VH polarizations separately, and the resulting t-values are combined to form a mean t-value image. This allows for the analysis of change detection in SAR imagery over a specified time period and orbit path.\n-- ///\n// Set functions //\n// Define a t-test function\nfunction ttest(s1, shock, pre_interval, post_interval) {\n  \n  // Convert the shock date to a date object\n  var shock = ee.Date(shock);\n  // Filter the image collection to the pre-event period\n  var pre = s1.filterDate(\n    shock.advance(ee.Number(pre_interval).multiply(-1), \"month\"),\n    shock\n  );\n  // Filter the image collection to the post-event period\n  var post = s1.filterDate(shock, shock.advance(post_interval, \"month\"));\n  \n  // Calculate the mean, standard deviation, and number of images for the pre-event period\n  var pre_mean = pre.mean();\n  var pre_sd = pre.reduce(ee.Reducer.stdDev());\n  var pre_n = ee.Number(pre.aggregate_array('orbitNumber_start').distinct().size());\n  \n  // Calculate the mean, standard deviation, and number of images for the pre-event period\n  var post_mean = post.mean();\n  var post_sd = post.reduce(ee.Reducer.stdDev());\n  var post_n = ee.Number(post.aggregate_array('orbitNumber_start').distinct().size());\n  \n  // Calculate the pooled standard deviation\n  var pooled_sd = pre_sd\n    .multiply(pre_sd)\n    .multiply(pre_n.subtract(1))\n    .add(post_sd.multiply(post_sd).multiply(post_n.subtract(1)))\n    .divide(pre_n.add(post_n).subtract(2))\n    .sqrt();\n\n    // Calculate the denominator of the t-test\n  var denom = pooled_sd.multiply(\n    ee.Number(1).divide(pre_n).add(ee.Number(1).divide(post_n)).sqrt()\n  );\n\n    // Calculate the Degrees of Freedom, which is the number of observations minus 2\n  var df = pre_n.add(post_n).subtract(2);\n\n  \n  var change = post_mean\n  　.abs()\n    .subtract(pre_mean)\n    .divide(denom)\n    .abs() //returning abs, so as t-value is bigger, the change becomes bigger.\n    //.subtract(2);\n\n    // return the t-values for each pixel\n    return change\n}\n\n// Define a satelite image after t-test\nfunction filter_s1(path) {\n\n  // Filter the image collection to the ascending or descending orbit\n  var orbits = ee\n    .ImageCollection(\"COPERNICUS/S1_GRD_FLOAT\")\n    .filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VH\"))\n    .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))\n    .filter(ee.Filter.eq(\"orbitProperties_pass\", path))\n    .filterBounds(aoi)\n    .filterDate('2023-01-01','2024-04-15')\n    .aggregate_array('relativeOrbitNumber_start')\n    .distinct()\n  \n  print(orbits)\n  \n  var image_col=ee.ImageCollection(orbits.map(function(orbit){\n\n  var s1 = ee\n    .ImageCollection(\"COPERNICUS/S1_GRD_FLOAT\")\n    .filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VH\"))\n    .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))\n    .filter(ee.Filter.eq(\"relativeOrbitNumber_start\",orbit))\n  \n  \n  // Calculate the t-test for the filtered image collection using the function we defined earlier\n  var vv = ttest(s1.select(\"VV\"), \"2024-01-01\", 12, 4)\n  var vh = ttest(s1.select(\"VH\"), '2024-01-01', 12, 4)\n  var vv= vv.rename('change');\n  var vh= vh.rename('change');\n  \n    // Return the t-values for each pixel\n  var image=ee.ImageCollection([vv,vh]).mean()\n\n  return image\n  })).mean()\n  \n  return image_col\n    \n  }\n\n\n\n// Set a dates //\nvar start = \"2023-01-01\";\nvar now = Date.now();\n//var now='2024-03-31'\nvar end = ee.Date(now).format();\n\n\n\n// Set an interface //\n\n// Create a Draw a Polygon botton\nvar drawButton = ui.Button({\n  label: \"🔺\" + \" Draw a Polygon\",\n  onClick: drawPolygon,\n  style: { stretch: \"horizontal\" },\n});\n\n// Create a Damage Assesment panel\nvar footagePanel = ui.Panel({\n  widgets: [\n    ui.Label(\"Damage Assessment\", {\n      fontWeight: \"bold\",\n      fontSize: \"20px\",\n    }),\n    ui.Label(\n      \"Click the button below and draw a box on the map to get an estimate of the number of damaged buildings in a given area\",\n      { whiteSpace: \"wrap\" }\n    ),\n    \n    drawButton,\n    ui.Label(),\n  ],\n  style: { position: \"top-left\", maxWidth: \"350px\", maxHeight:'90%'},\n  layout: ui.Panel.Layout.flow(\"vertical\", true),\n});\n\n\n// Define a color scale function\nfunction makeColorBarParams(palette) {\n  return {\n    bbox: [0, 0, 1, 0.1],\n    dimensions: \"100x10\",\n    format: \"png\",\n    min: 0,\n    max: 1,\n    palette: palette.reverse(),\n  };\n}\nvar reds = [\"yellow\", \"red\", \"purple\"];\n\n// Create the color bar\nvar colorBar = ui.Thumbnail({\n  image: ee.Image.pixelLonLat().select(0),\n  params: makeColorBarParams(reds.reverse()),\n  style: { stretch: \"horizontal\", margin: \"0px 8px\", maxHeight: \"24px\" },\n});\n\n// Create the title for the color bar\nvar legendTitle = ui.Label({\n  value: \"Estimated Damage (t-value)\",\n  style: { fontWeight: \"bold\" ,textAlign: \"center\",stretch: \"horizontal\"},\n});\n\n// Create the panel for the color bar\nvar legendLabels = ui.Panel({\n  widgets: [\n    ui.Label('Low', { margin: \"4px 8px\" }),\n    ui.Label( \" \", {\n      margin: \"4px 8px\",\n      textAlign: \"center\",\n      stretch: \"horizontal\",\n    }),\n    ui.Label('High', { margin: \"4px 8px\" }),\n    ],\n  layout: ui.Panel.Layout.flow(\"horizontal\"),\n});\n\n// Create the scale\nvar scalePanel = ui.Panel({\n  widgets: [\n    ui.Label('2.5', { margin: \"4px 8px\" }), \n    ui.Label( \" \", {\n      margin: \"4px 8px\",\n      textAlign: \"center\",\n      stretch: \"horizontal\",\n    }),\n    ui.Label('6.0', { margin: \"4px 8px\" }), \n  ],\n  layout: ui.Panel.Layout.flow(\"horizontal\"),\n});\n\n// Set the panel \nvar legendPanel = ui.Panel({\n  widgets: [legendTitle, scalePanel, colorBar, legendLabels],\n  style: { position: \"bottom-left\", Width: \"350px\"},\n});\n\n\n\n// Apply for a Japan case //\n// Create mapPanel_building\nvar mapPanel_building = ui.Map();\nmapPanel_building.setOptions('SATELLITE');\n\n// Show mapPanel_building\nui.root.widgets().set(0, mapPanel_building);\n\n\n// Define a function for returning an image of damaged buildings\nfunction footprints(cutoff, aoi, label) {\n  var footprints = ee.FeatureCollection('projects/ee-rengeanzu/assets/location-points-to-polygonss')\n    .filterBounds(aoi)\n    .map(function(feat) {\n      return feat.set('area', feat.geometry().area(10)).set('geometry_type', feat.geometry().type());\n    })\n    .filter(ee.Filter.gt('area', 50));　//remove under 50 m2 buildings\n\n  var mean = image.reduceRegions({\n    collection: footprints,\n    reducer: ee.Reducer.mean(),\n    scale: 10\n  });\n  var damaged = mean.filter(ee.Filter.gt('mean', cutoff))\n\n  print(damaged.size())\n  \n  var totalCount = mean.size()\n  var damagedCount = damaged.size()\n  var proportion = ((damagedCount.divide(totalCount)).multiply(100)).int() // .evaluate(function(val){return val});\n\n\n  var outlines = ui.Map.Layer(damaged, {\n    color: 'red'\n  }, 'footprints');\n\n  mapPanel_building.layers().set(0, outlines)\n  mapPanel_building.layers().get(0).setShown(true)\n  mapPanel_building.layers().get(1).setShown(false)\n}\n\n\n// Define \"change\" layer\nfunction clear() {\n  // Define a clear map\n  mapPanel_building.clear()\n\n  mapPanel_building.setOptions('SATELLITE')\n  mapPanel_building.setControlVisibility({\n    all: false\n  });\n  mapPanel_building.setControlVisibility({\n    layerList: true,\n    mapTypeControl: true\n  }); \n\n  var urban = ee.ImageCollection('GOOGLE/DYNAMICWORLD/V1').filterDate('2023-01-01', '2024-04-15').mean().select('built')\n\n  var boxcar = ee.Kernel.gaussian({\n    radius: 50,\n    units: 'meters',\n    normalize: true,\n    sigma: 20\n  });\n\n  // Call the filter_s1 function once for each orbit, and then combine the two images into a single image\n  var asc = filter_s1(\"ASCENDING\")\n  var desc = filter_s1(\"DESCENDING\")\n\n  var image = ee\n    .ImageCollection([asc, desc]).mean().convolve(boxcar)\n    .updateMask(urban.gt(0.3))\n\n  // Add the composite to the map\n  var reds = [\"yellow\", \"red\", \"purple\"];\n\n  // Add the composite to the map\n  var damage_layer = ui.Map.Layer(\n    image.updateMask(image.gt(2.5)), {\n      min: 2.5,\n      max: 6,\n      opacity: 0.8,\n      palette: reds\n    },\n    \"change\"\n  );\n\n  mapPanel_building.layers().set(0, damage_layer)\n  mapPanel_building.style().set(\"cursor\", \"crosshair\");\n  mapPanel_building.centerObject(initialPoint, 14);\n  mapPanel_building.add(legendPanel);\n\n\n  return image\n}\n\n\n// Define a function to clear map and add a Damage Assesment panel\nfunction home() {\n  var image = clear()\n\n  mapPanel_building.add(footagePanel)\n  return image\n}\n\n\n// Define a Draw a Polygon button\nvar drawingTools = mapPanel_building.drawingTools();\n\ndrawingTools.setShown(false);\n\nwhile (drawingTools.layers().length() &gt; 0) {\n  var layer = drawingTools.layers().get(0);\n  drawingTools.layers().remove(layer);\n}\n\nvar dummyGeometry = ui.Map.GeometryLayer({ \n  geometries: null,\n  name: \"geometry\",\n  color: \"23cba7\",\n}).setShown(false);\n\ndrawingTools.layers().add(dummyGeometry)\n\nfunction clearGeometry() {\n  var layers = drawingTools.layers();\n  layers.get(0).geometries().remove(layers.get(0).geometries().get(0));\n}\n\nfunction drawPolygon() {\n  clearGeometry();\n  drawingTools.setShape(\"rectangle\");\n  drawingTools.draw();\n}\n\nfunction drawPoint() {\n  clearGeometry();\n  drawingTools.setShape(\"point\");\n  //var pointBuffer = point.buffer({'distance': 100});\n  drawingTools.draw();\n}\n\n\n// Run a footprints function\nfunction footprints() {\n  var aoi = drawingTools.layers().get(0).getEeObject();\n  drawingTools.layers().get(0).setShown(false);\n\n  var footprints = ee.FeatureCollection('projects/ee-rengeanzu/assets/location-points-to-polygons')\n    .filterBounds(aoi)\n    .map(function(feat) {\n      return feat.set('area', feat.geometry().area(10)).set('geometry_type', feat.geometry().type());\n\n    })\n    .filter(ee.Filter.gt('area', 50))\n    .filter(ee.Filter.equals('geometry_type', 'Polygon'));\n\n  var mean = image.reduceRegions({\n    collection: footprints,\n    reducer: ee.Reducer.mean(),\n    scale: 10\n  });\n  var damaged = mean.filter(ee.Filter.gt('mean', 1.96)) //95% confidence period\n\n  var totalCount = mean.size()\n  var damagedCount = damaged.size()\n  var proportion = ((damagedCount.divide(totalCount)).multiply(100)).int() // .evaluate(function(val){return val});\n\n  var sumLabel2 = ui.Label({\n    value: 'Calculating...'\n  })\n  var meanLabel2 = ui.Label({\n    value: 'Calculating...'\n  })\n\n  damagedCount.evaluate(function(val) {\n    sumLabel2.setValue(val)\n  });\n  proportion.evaluate(function(val) {\n    meanLabel2.setValue(val)\n  });\n\n  var sumLabel1 = ui.Label(\"Number of damaged buildings in the area: \")\n  var meanLabel1 = ui.Label(\"Proportion (%): \")\n\n  var sumPanel = ui.Panel({\n    layout: ui.Panel.Layout.flow('horizontal'),\n    widgets: [sumLabel1, sumLabel2]\n  })\n  var meanPanel = ui.Panel({\n    layout: ui.Panel.Layout.flow('horizontal'),\n    widgets: [meanLabel1, meanLabel2]\n  })\n\n  var statsPanel = ui.Panel([sumPanel, meanPanel])\n\n  footagePanel.widgets().set(4, statsPanel);\n\n  Export.table.toDrive({\n    collection: damaged,\n    description: '_damaged_buildings',\n  });\n\n  Export.image.toDrive({\n    image: image.clip(aoi),\n    scale: 10,\n    description: '_damage',\n  });\n\n  var outlines = ui.Map.Layer(damaged, {\n    color: 'red'\n  }, 'footprints');\n\n  mapPanel_building.layers().set(1, outlines)\n  mapPanel_building.layers().get(0).setShown(false)\n}\n\nvar image = home()\n\ndrawingTools.onDraw(footprints);\n\nmapPanel_building.add(buttonPanel);\n\n\n\nPixelwise T-Test, 2023-24\n\n\nand math: \\[ \\Large t = {\\frac{\\overline{x_1}-\\overline{x_2}} {\\sqrt{\\frac{s^2_1}{n_1} + \\frac{s^2_2}{n_2}}}} \\]\n\n\n\nThe code snippet provides a landslide detection visualization tool using Sentinel-1 GRD imagery. It calculates the mean difference between pre and post-event periods, applying a threshold to create a mask highlighting areas of significant change. The masked layer, showing the difference more clearly, is overlaid on the map along with the original landslide detection layer, enabling users to visualize and assess potential landslide areas effectively.\nTo enhance the analysis, additional features such as building footprints or vegetation indices like NDVI/NIR could be integrated. Clipping the analysis to land areas using multipoint geometry could provide more accurate results. Adjusting the threshold for the mask can improve the display by focusing on areas with substantial changes, aiding in the identification and assessment of landslide risks. Users can interact with the map interface to explore different layers and adjust parameters for more comprehensive landslide detection and visualization.\n// Set up the Area of Interest (AOI)\nvar point = ee.Geometry.Point([136.89961, 37.39405]); // Center point\nvar aoi = point.buffer(10000); // 10 km buffer around the point\n\n// Define the time range for pre- and post-event analysis\nvar preStart = '2023-08-01';\nvar preEnd = '2023-12-31';\nvar postStart = '2024-01-02';\nvar postEnd = '2024-03-31';\n\n// Load the Sentinel-2 Image Collection within the specified dates and area\nvar s2 = ee.ImageCollection('COPERNICUS/S2')\n          .filterBounds(aoi)\n          .filterDate(preStart, postEnd)\n          .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10));\n\n// Function to calculate NDVI\nfunction addNDVI(image) {\n  var ndvi = image.normalizedDifference(['B8', 'B4']).rename('NDVI');\n  return image.addBands(ndvi);\n}\n\n// Apply the NDVI function to each image in the collection\nvar ndviCollection = s2.map(addNDVI);\n\n// Compute median NDVI images for pre and post periods\nvar preNDVI = ndviCollection.filterDate(preStart, preEnd).median().select('NDVI');\nvar postNDVI = ndviCollection.filterDate(postStart, postEnd).median().select('NDVI');\n\n// Calculate NDVI difference to highlight changes\nvar ndviDiff = postNDVI.subtract(preNDVI).rename('NDVI_Diff');\n// Calculate NDVI difference\nvar ndviDifference = postNDVI.subtract(preNDVI);\n\n// Sampling points for training\n// Assume points are pre-classified as 1 (landslide) or 0 (no landslide)\nvar points = ee.FeatureCollection([\n    ee.Feature(ee.Geometry.Point([137.1018965847964,37.45891870504624]), {label: 1}),\n    ee.Feature(ee.Geometry.Point([136.8232291924816,37.34724623299005]), {label: 0})\n]);\n\n// Overlay the points on the NDVI difference to extract training data\nvar training = ndviDifference.sampleRegions({\n    collection: points,\n    properties: ['label'],\n    scale: 10\n});\n\n// Train a Random Forest classifier\nvar classifier = ee.Classifier.smileRandomForest(50).train({\n    features: training,\n    classProperty: 'label',\n    inputProperties: ['NDVI']\n});\n\n// Apply the classifier to the NDVI difference image\nvar classified = ndviDifference.classify(classifier);\n\n// Visualize clusters\n\n// Load and filter additional datasets for roads and water bodies\nvar roads = ee.FeatureCollection('TIGER/2016/Roads').filterBounds(aoi);\nvar waterBodies = ee.FeatureCollection('HYCOM/sea_water_velocity');\n//var buildings = ee.FeatureCollection('GlobalHumanSettlementLayer/GHS_BUILT_LDSMT_GLOBE_V1').filterBounds(aoi);\n\n\n// Visualization parameters\nvar visParams = {\n  bands: ['NDVI_Diff'],\n  min: -0.5,\n  max: 0.5,\n  palette: ['blue', 'white', 'red']\n};\n\nvar roadParams = {\n  color: 'yellow',\n  width: 1\n};\n\nvar waterParams = {\n  color: 'blue',\n  width: 1\n};\n//var clusterVis = {min: 0, max: 2, palette: ['cyan', 'orange', 'purple']};\n// Adding layers to the Map\n\n// Create a map layer control panel.\nvar panel = ui.Panel({style: {width: '300px'}});\nvar mapPanel_landslide = ui.Map();\nmapPanel_landslide.centerObject(initialPoint, 14);\nmapPanel_landslide.setOptions(\"SATELLITE\");\n// Add layers to the map.\nmapPanel_landslide.add(ui.Map.Layer(preNDVI.select('NDVI'), {min: -1, max: 1, palette: ['blue', 'white', 'green']}, 'Pre-event NDVI', false));\nmapPanel_landslide.add(ui.Map.Layer(postNDVI.select('NDVI'), {min: -1, max: 1, palette: ['blue', 'white', 'green']}, 'Post-event NDVI', false));\nmapPanel_landslide.add(ui.Map.Layer(ndviDiff, visParams, 'NDVI Difference', false));\nmapPanel_landslide.add(ui.Map.Layer(classified, {min: 0, max: 1, palette: ['blue', 'red'], opacity: 0.5}, 'Landslide Prediction', true));\nmapPanel_landslide.add(ui.Map.Layer(roads.style(roadParams), {}, 'Roads', false));\nmapPanel_landslide.add(ui.Map.Layer(waterBodies.style(waterParams), {}, 'Water Bodies', false));\n\n// Create checkbox widgets for layer visibility.\nvar checkbox1 = ui.Checkbox('Show Pre-event NDVI', false, function(checked) {\n  mapPanel_landslide.layers().get(0).setShown(checked);\n});\nvar checkbox2 = ui.Checkbox('Show Post-event NDVI', false, function(checked) {\n  mapPanel_landslide.layers().get(1).setShown(checked);\n});\nvar checkbox3 = ui.Checkbox('Show NDVI Difference', false, function(checked) {\n  mapPanel_landslide.layers().get(2).setShown(checked);\n});\nvar checkbox4 = ui.Checkbox('Show Landslide Detection', true, function(checked) {\n  mapPanel_landslide.layers().get(3).setShown(checked);\n  \n});\nvar checkbox5 = ui.Checkbox('Show Roads', false, function(checked) {\n  mapPanel_landslide.layers().get(4).setShown(checked);\n});\nvar checkbox6 = ui.Checkbox('Show Water Bodies', false, function(checked) {\n  mapPanel_landslide.layers().get(5).setShown(checked);\n});\n\nvar title = ui.Label('Classifier Details', {fontWeight: 'bold'});\npanel.add(title);\nvar validation = classified.sampleRegions({\n  collection: points,\n  properties: ['label'],\n  scale: 10,\n});\n\nvar confusionMatrix = validation.errorMatrix('label', 'classification');\n\n// Add confusion matrix and accuracy to the panel\nvar matrixLabel = ui.Label('Confusion Matrix:');\nvar matrixValue = ui.Label(confusionMatrix.array().getInfo());\npanel.add(matrixLabel);\npanel.add(matrixValue);\n\nvar accuracyLabel = ui.Label('Overall Accuracy:');\nvar accuracyValue = ui.Label(confusionMatrix.accuracy().getInfo());\npanel.add(accuracyLabel);\npanel.add(accuracyValue);\n// Function to create and style the legend\nfunction createLegend() {\n  var legend = ui.Panel({\n    style: {\n      position: 'bottom-left',\n      padding: '8px 15px'\n    }\n  });\n\n  // Create legend title\n  var legendTitle = ui.Label({\n    value: 'Landslide prediction',\n    style: {\n      fontWeight: 'bold',\n      fontSize: '18px',\n      margin: '0 0 4px 0',\n      padding: '0'\n    }\n  });\n\n  // Add the title to the legend\n  legend.add(legendTitle);\n\n  // Set legend keys and descriptions\n  var names = ['No landslide - Blue', 'Landslide - Red'];\n  var colors = ['blue', 'red']; // These should match 'palette' in visParams\n\n  // Add color boxes and labels to the legend\n  for (var i = 0; i &lt; names.length; i++) {\n    var colorBox = ui.Label({\n      style: {\n        backgroundColor: colors[i],\n        // Make sure the color box is square\n        padding: '8px',\n        margin: '0 0 4px 0'\n      }\n    });\n\n    var description = ui.Label({\n      value: names[i],\n      style: {margin: '0 0 4px 6px'}\n    });\n\n    // Make a horizontal panel to hold the color box and description\n    var colorPanel = ui.Panel({\n      widgets: [colorBox, description],\n      layout: ui.Panel.Layout.Flow('horizontal')\n    });\n\n    // Add the color panel to the legend\n    legend.add(colorPanel);\n  }\n\n  return legend;\n}\n\n// Create the legend\nvar legend = createLegend();\n\n// Create a checkbox to toggle the legend's visibility\nvar checkbox = ui.Checkbox('Landslide prediction Legend', true, function(checked) {\n  // Show or hide the legend based on the checkbox\n  legend.style().set('shown', checked);\n});\n\n// Add the checkbox and the legend to the UI\npanel.add(checkbox);\nmapPanel_landslide.add(legend);\n\n// Add the widgets to the panel and add the panel to the map.\npanel.add(checkbox1);\npanel.add(checkbox2);\npanel.add(checkbox3);\npanel.add(checkbox4);\npanel.add(checkbox5);\npanel.add(checkbox6);\nmapPanel_landslide.add(panel);\n\n// Add the map to the UI.\n//ui.root.add(map);\n\n\n\nMachine Learning (Random Forest Analysis), 2024\n\n\n\n\n\nThe code snippet creates a fire burn area visualization tool in Earth Engine’s JavaScript API. It allows users to select different fire datasets and years using dropdown menus and sliders, respectively. Upon selection, the map dynamically updates to display the burned areas for the chosen dataset and year, aiding in the assessment and monitoring of fire impacts over time and across different datasets.\nvar mapPanel_fire = ui.Map();\nmapPanel_fire.centerObject(initialPoint, 14);\nmapPanel_fire.setOptions(\"satellite\");\n\n\nvar footprints_fire = ee.FeatureCollection('projects/ee-rengeanzu/assets/location-points-to-polygons')\n  .filterBounds(aoi)\n  .map(function(feat) {\n    return feat.set('area', feat.geometry().area(10)).set('geometry_type', feat.geometry().type());\n  })\n  .filter(ee.Filter.gt('area', 50))\n  .filter(ee.Filter.equals('geometry_type', 'Polygon'));\n\nvar mean = image.reduceRegions({\n  collection: footprints_fire,\n  reducer: ee.Reducer.mean(),\n  scale: 10\n});\n\n\n\nvar empty_fire = ee.Image().byte();\n\n// Paint the building footprints onto the empty image\nvar outline_fire = empty_fire.paint({ \n  featureCollection: mean.filter(ee.Filter.gt('mean', 2.5)),\n  color: \"mean\",\n  width: 1,\n});\n\n// Dilate the painted areas to make the outline thicker\nvar dilated_outline_fire = outline_fire.focal_max({ radius: 3, kernelType: 'circle', iterations: 1 });\n\n// Define a color palette\nvar building_palette_fire = [\n  '70db70', 'ff9933', '7500fa'\n];\n\n// Add the image to the map\nmapPanel_fire.addLayer(\n  dilated_outline_fire,\n  { min: 2.5,\n    max: 6,\n    palette: building_palette_fire,\n    opacity: 0.8 },\n  \"Damaged Buildings for Fire\"\n);\n\n\n\n// // fire data layer\nvar firePoints = ee.FeatureCollection('projects/ee-rengeanzu/assets/df1_filter');\n\n\n// Generate an impact circle area for each fire spot\nvar radii = [15, 50, 100];  // The unit is meters\nvar fireBuffers = firePoints.map(function(feature) {\n  var buffers = ee.FeatureCollection(radii.map(function(radius) {\n    return feature.buffer(radius).set('radius', radius); \n  }));\n  return buffers;\n}).flatten();\n// Setting the display colors for different radii\nvar colors = ['FF0000'];\nvar opacities = ['44', '88', 'FF'];  \nvar styledBuffers = fireBuffers.map(function(feature) {\n  // Retrieve the 'radius' property of the feature, set a default if undefined\n  var radius = feature.get('radius') || 10;  \n  var idx = radii.indexOf(radius);  \n\n  // Use default index if idx is invalid\n  if (idx === -1 || idx === undefined) {\n    idx = 0;  // Use a safe default index\n  }\n\n  // Use valid colors and opacities, or use default values\n  var color = colors[idx] || 'FF0000';  \n  var opacity = opacities[idx] || 'FF'; \n  var fillColor = color + opacity; \n\n  // Define the style\n  var style = {\n    color: color,\n    fillColor: fillColor,\n    fillOpacity: 0.5  // Set fill opacity\n  };\n\n  // Apply the style\n  return feature.set('style', style);\n});\n\n// Display the buffer zones on the map\nmapPanel_fire.addLayer(styledBuffers.style({styleProperty: 'style'}), {}, 'Impact Zones');\n\n\n// Create a panel to hold labels and a legend\nvar panel_fire = ui.Panel({\n  style: {\n    width: '300px',\n    padding: '8px',\n    position: \"top-left\"\n  }\n});\n\n// Create labels to explain the layers\nvar introLabel = ui.Label({\n  value: 'Map Layer Explanation',\n  style: {fontWeight: 'bold', fontSize: '16px', margin: '0 0 4px 0'}\n});\n\nvar fireLabel = ui.Label({\n  value: 'Fire Impact Zones: Circles of different colors and radii represent varying levels of fire impact.',\n  style: {fontSize: '12px', margin: '0 0 4px 0'}\n});\n\nvar damageLabel = ui.Label({\n  value: 'Damaged Buildings: Different colors indicate the degree of damage to buildings.',\n  style: {fontSize: '12px', margin: '0 0 4px 0'}\n});\n\n// Add labels to the panel\npanel_fire.add(introLabel);\npanel_fire.add(fireLabel);\npanel_fire.add(damageLabel);\n\n// Define a function to create a color legend\nfunction createLegendItem(color, description) {\n  var colorBox = ui.Label({\n    style: {\n      backgroundColor: '#' + color,\n      // Ensure proper size of the color box\n      padding: '8px',\n      margin: '0 8px 4px 0'\n    }\n  });\n\n  var descriptionLabel = ui.Label({\n    value: description,\n    style: {margin: '0 0 4px 6px'}\n  });\n\n  return ui.Panel({\n    widgets: [colorBox, descriptionLabel],\n    layout: ui.Panel.Layout.Flow('horizontal')\n  });\n}\n\n// Add a legend title to the panel\nvar legendTitle = ui.Label({\n  value: 'Legend',\n  style: {fontWeight: 'bold', fontSize: '14px', margin: '8px 0 4px 0'}\n});\npanel_fire.add(legendTitle);\n\n// Add specific color legend items\nvar colors = ['70db70', 'ff9933', '7500fa'];\nvar descriptions = [\n  'Minor damage - Light green',\n  'Moderate damage - Yellow',\n  'Critical damage - Deep purple'\n];\n\ncolors.forEach(function(color, index) {\n  panel_fire.add(createLegendItem(color, descriptions[index]));\n});\n\n\n\nMachine Learning (Random Forest Analysis), 2024\n\n\n\n\n\nThe provided JavaScript code is a Google Earth Engine script designed to simulate the inundation of buildings caused by a tsunami event. It utilizes elevation data from the USGS SRTMGL1 dataset to determine flooded areas at various water levels. The script loads a CSV file containing building footprints and iterates over different flood levels, displaying the impacted buildings on a map. It distinguishes flooded buildings at different water levels using different colors and provides a legend panel to explain the color scheme.\nThe script initializes a map panel centred on a specific location and loads elevation data and building footprints within a defined area of interest. It then computes and visualizes the affected buildings at different flood levels, allowing for the assessment of tsunami inundation impact on infrastructure. Additionally, it constructs a legend panel to provide a clear explanation of the color-coded representation of flooded buildings at various water levels, enhancing the interpretability of the map visualization.\n\n  /// ------------------------------------- AREA ------------------------------------- ///\n\n// Create a mappanel for tsunami area\nvar mapPanel_tsunami = ui.Map();\nmapPanel_tsunami.centerObject(initialPoint, 14);\nmapPanel_tsunami.setOptions(\"SATELLITE\");\n\n// Load the elevation data\nvar elevation = ee.Image('USGS/SRTMGL1_003').clip(aoi);\n\nvar bluePalette = [\n    '#00008B',   // Dark blue\n    '#333399',   // Darker blue\n    '#666699',   // Even darker blue\n    '#9999CC',   // Slightly lighter blue\n    '#CCCCFF',   // Light blue\n    '#FFFFCC',   // Lightest yellow\n];\n\n// Variable to store the previous flooded area\nvar previousFlooded = ee.Image.constant(0).clip(aoi);\n\n// Iterate over different flood levels\n[1, 3, 5, 7, 9, 11].forEach(function(level, index) {\n    // Compute the flooded area at the current water level\n    var currentFlooded = elevation.lte(level);\n\n    // Exclude areas affected by previous water levels\n    var newFloodedArea = currentFlooded.and(previousFlooded.not());\n\n    // Update the previously flooded area\n    previousFlooded = previousFlooded.or(currentFlooded);\n\n    var visualization = {\n        palette: [bluePalette[index]],\n        min: 0,\n        max: 1,\n        opacity: 0.5\n    };\n\n    // Visualize the newly flooded area at the current water level\n    mapPanel_tsunami.addLayer(newFloodedArea.updateMask(newFloodedArea), visualization, 'Flooded at ' + level + 'm');\n});\n\n// Create a panel to display layer annotations\nvar legend_tsunami = ui.Panel({\n    style: {\n        position: 'bottom-left',\n        padding: '8px 15px'\n    }\n});\n\n// Add a title for layer annotations\nvar legendTitle_tsunami = ui.Label({\n    value: 'Layer Description',\n    style: {\n        fontWeight: 'bold',\n        fontSize: '18px',\n        margin: '0 0 4px 0',\n        padding: '0'\n    }\n});\nlegend_tsunami.add(legendTitle_tsunami);\n\nvar layers = [\n    {name: 'Flooded at 1m', color: bluePalette[0]},\n    {name: 'Flooded at 3m', color: bluePalette[1]},\n    {name: 'Flooded at 5m', color: bluePalette[2]},\n    {name: 'Flooded at 7m', color: bluePalette[3]},\n    {name: 'Flooded at 9m', color: bluePalette[4]},\n    {name: 'Flooded at 11m', color: bluePalette[5]},\n];\n\nlayers.forEach(function(layer) {\n    // Create a panel with a horizontal layout\n    var layerItem = ui.Panel({\n        widgets: [\n            ui.Label({\n                value: '■', // Use a square symbol for the color block\n                style: {\n                    color: layer.color, // Set the color of the color block\n                    fontWeight: 'bold',\n                    fontSize: '18px', // Adjust size to fit annotation\n                    margin: '0 4px 0 0' // Right margin to separate color block and text\n                }\n            }),\n            ui.Label({\n                value: layer.name,\n                style: {\n                    color: 'black', // Text color\n                    margin: '0',\n                    fontSize: '16px' // Text size\n                }\n            })\n        ],\n        layout: ui.Panel.Layout.flow('horizontal')\n    });\n    // Add the annotation for each layer to the legend panel\n    legend_tsunami.add(layerItem);\n});\n\nvar tsunamiLabel = ui.Label('Simulation of tsunami inudation', \n{position: 'top-left', fontWeight: 'bold', fontSize: '24px'});\n mapPanel_tsunami.add(tsunamiLabel);\n  mapPanel_tsunami.add(legend_tsunami);\n  \n  \n  /// ------------------------------------- BUILDINGS ------------------------------------- ///\nvar mapPanel_tsunami2 = ui.Map();\nmapPanel_tsunami2.centerObject(initialPoint, 14);\nmapPanel_tsunami2.setOptions(\"SATELLITE\");\n\n// Define the area of interest (AOI) as a buffer of 3 kilometers around the center point\nvar aoi = ee.Geometry.Point(136.89961, 37.39405).buffer(3000);\n\n// Load the elevation data\nvar elevation = ee.Image('USGS/SRTMGL1_003').clip(aoi);\n\n// Load the CSV file containing building footprints\n// var csv = ee.FeatureCollection('projects/ee-rengeanzu/assets/202312BuildingFootprints').filterBounds(aoi);\n\n// Define an array of flood levels\nvar floodLevels = ee.List.sequence(1, 11);\n\n// Create a slider\nvar floodSlider = ui.Slider({\n  min: 1,\n  max: 11,\n  value: 1,\n  step: 1,\n  style: {stretch: 'horizontal'}\n});\n\n// Create a label to display the count\nvar countLabel = ui.Label('');\nvar label = ui.Label('Select flood level (meters):');\n\n// Create a panel containing the label, slider, and count\nvar panel = ui.Panel({\n  widgets: [label, floodSlider, countLabel],\n  style: {\n    position: 'bottom-left',\n    padding: '8px 15px'\n  }\n});\n\nmapPanel_tsunami2.add(panel);\n\n\nvar buildings = ee\n   .FeatureCollection(\"projects/ee-rengeanzu/assets/202312BuildingFootprints\")\n   .filterBounds(aoi);\n\n// Function to compute and display the impact of flooding at a specific water level\nfunction displayFloodImpact(floodLevel) {\n    // Flooded area at the current water level\n    var flooded = elevation.lte(floodLevel);\n    var floodedPoints = buildings.map(function(feature) {\n        return feature.set('isFlooded', flooded.reduceRegion({\n            reducer: ee.Reducer.anyNonZero(),\n            geometry: feature.geometry(),\n            scale: 30\n        }).get('elevation'));\n    }).filter(ee.Filter.eq('isFlooded', 1));\n\n    // Update the map layer and count\n    floodedPoints.size().evaluate(function(size) {\n        countLabel.setValue('Number of flooded buildings: ' + size);\n    });\n\n    // Visualize flooded buildings\n    var floodLayer = ui.Map.Layer(floodedPoints, {color: 'red'}, 'Flooded Buildings at ' + floodLevel + 'm', true, 0.6);\n    mapPanel_tsunami2.layers().set(0, floodLayer);\n}\n\n// Listen to slider changes\nfloodSlider.onSlide(function(value) {\n    displayFloodImpact(value);\n});\n\n// Initialize display\ndisplayFloodImpact(1);\n\n// Add a title\nmapPanel_tsunami2.add(ui.Label('The number of buildings estimated to be flooded', {position: 'top-left', fontWeight: 'bold', fontSize: '24px'}));\n\n\nvar mapPanel_tsunami = ui.Map();\nmapPanel_tsunami.centerObject(initialPoint, 14);\nmapPanel_tsunami.setOptions(\"SATELLITE\");\n\n// Load the elevation data\nvar elevation = ee.Image('USGS/SRTMGL1_003').clip(aoi);\n\n// Load the CSV file containing building footprints\n// var csv = ee.FeatureCollection('projects/ee-rengeanzu/assets/202312BuildingFootprints').filterBounds(aoi);\n\nvar bluePalette = [\n    '#00008B',  // Dark blue\n    '#0000CD',  // Medium blue\n    '#4169E1',  // Royal blue\n    '#FFA500',\n    '#FFD700', // Gold\n    '#FFFF00',  // Yellow\n];\n\n// Variable to store the previous flooded area\nvar previousFlooded = ee.Image.constant(0).clip(aoi);\n\n// Iterate over different flood levels\n[1, 3, 5, 7, 9, 11].forEach(function(level, index) {\n    // Compute the flooded area at the current water level\n    var currentFlooded = elevation.lte(level);\n\n    // Exclude areas affected by previous water levels\n    var newFloodedArea = currentFlooded.and(previousFlooded.not());\n\n    // Update the previously flooded area\n    previousFlooded = previousFlooded.or(currentFlooded);\n\n    var visualization = {\n        palette: [bluePalette[index]],\n        min: 0,\n        max: 1,\n        opacity: 0.5\n    };\n\n    // Visualize the newly flooded area at the current water level\n    mapPanel_tsunami.addLayer(newFloodedArea.updateMask(newFloodedArea), visualization, 'Flooded at ' + level + 'm');\n});\n\n// Create a panel to display layer annotations\nvar legend_tsunami = ui.Panel({\n    style: {\n        position: 'bottom-left',\n        padding: '8px 15px'\n    }\n});\n\n// Add a title for layer annotations\nvar legendTitle_tsunami = ui.Label({\n    value: 'Layer Description',\n    style: {\n        fontWeight: 'bold',\n        fontSize: '18px',\n        margin: '0 0 4px 0',\n        padding: '0'\n    }\n});\nlegend_tsunami.add(legendTitle_tsunami);\n\nvar layers = [\n    {name: 'Flooded at 1m', color: bluePalette[0]},\n    {name: 'Flooded at 3m', color: bluePalette[1]},\n    {name: 'Flooded at 5m', color: bluePalette[2]},\n    {name: 'Flooded at 7m', color: bluePalette[3]},\n    {name: 'Flooded at 9m', color: bluePalette[4]},\n    {name: 'Flooded at 11m', color: bluePalette[5]},\n];\n\nlayers.forEach(function(layer) {\n    // Create a panel with a horizontal layout\n    var layerItem = ui.Panel({\n        widgets: [\n            ui.Label({\n                value: '■', // Use a square symbol for the color block\n                style: {\n                    color: layer.color, // Set the color of the color block\n                    fontWeight: 'bold',\n                    fontSize: '18px', // Adjust size to fit annotation\n                    margin: '0 4px 0 0' // Right margin to separate color block and text\n                }\n            }),\n            ui.Label({\n                value: layer.name,\n                style: {\n                    color: 'black', // Text color\n                    margin: '0',\n                    fontSize: '16px' // Text size\n                }\n            })\n        ],\n        layout: ui.Panel.Layout.flow('horizontal')\n    });\n    // Add the annotation for each layer to the legend panel\n    legend_tsunami.add(layerItem);\n});\n\nvar tsunamiLabel = ui.Label('Simulation of tsunami inundation on City of Wajima', \n{position: 'top-left', fontWeight: 'bold', fontSize: '24px'});\n mapPanel_tsunami.add(tsunamiLabel);\n  mapPanel_tsunami.add(legend_tsunami);\n  \n  \n  var mapPanelLayout = ui.Panel({\n  widgets: [\n    mapPanel_tsunami,\n    mapPanel_tsunami2\n  ],\n  layout: ui.Panel.Layout.flow('horizontal'), // Arrange panels horizontally\n  style: { width: '100%', stretch: \"horizontal\" } })// Set panel size;\n\n\n\nAssumptions: Flood levels, 2024\n\n\n\n\n\n\nOne may witness the change from before and after building damage representing the pre-disaster and post-disaster."
  },
  {
    "objectID": "index.html#project-summary",
    "href": "index.html#project-summary",
    "title": "CASA00025 : Comprehensive Multi-Disaster Application",
    "section": "",
    "text": "Spatial events are complex and often entail chain reactions. Moreover, severe ripple effects can be observed, especially during disasters in densely populated urban areas. It becomes imperative to understand such disaster events collectively to comprehend the domino effect and its implications. Thus, the project aims to create an application to assess multiple disaster events.\n\n\n\nApplication Overview\n\n\n\n\nWith increasing anthropological interference with nature and non-environmentally friendly development, the risk of disasters across the globe is on the rise. The present body of knowledge witnesses that disaster events are often studied in silos. However, recent evidence from Japan shows that more than one disaster can occur simultaneously, such as earthquakes, tsunamis, fires, and landslides. On January 1st, 2024, an earthquake with a magnitude of 7.5 hit the Noto Peninsula, Japan, resulting in an estimated 10,000 buildings damaged or destroyed. The extent and intensity of the disaster in the Noto Peninsula, which consists of 300-400 meter mountains and elevations, presents varying geographic conditions, embedding a multi-nature of land-forms and its events, making it difficult to assess the multi-disaster occurrence together or as a chain of activities. In order to identify the overlapping extent and intensity of the multiple-disaster impact, the attempted application seeks to estimate spatial and physical implications using satellite imagery. Therefore, a multi-disaster map layer could provide the extent of spatial severity and impact to assess various areas and building-level and area-level measures. Thus, the complex urban system requires a comprehensive assessment tool.\n\n\n\nVarious stakeholders have been identified who can benefit from the application. The Japan Ministry of Disaster Management is one such stakeholder that could use the application to assess the typology of disasters, whether individually or comprehensively. Understanding the disasters holistically, the housing department may utilize the application to carry out suitable building retrofitting or renovation. Additionally, appropriate beneficiary schemes may use the application to provide compensation. Furthermore, the Ministry of Land, Infrastructure, Transport, and Tourism could further analyze the epicenter from individual disaster and combined disaster event scenarios. Thus, Ishikawa Prefecture (Local Authority) and reconstruction agencies are also relevant stakeholders. Studies, research, and reports on building investigation (e.g., material and years), level of damage could be conducted, aiding in policy interventions such as the review of the Building Standards Act. Beneficiary schemes (e.g., compensation) or reconstruction for Future Urban Planning, as well as for immediate rescue and search bots, may also benefit from the application.\n\n\n\nData-driven assessment and decision-making application could provide ease of interaction for users to understand and action upon. In order to handle ginormous datasets to plan and manage complex spatial phenomena for above identified stakeholders could be enabled by create a user interface to disseminate information and knowledge. Thus, Sentinel-1 Synthetic Aperture Radar (SAR) imagery, Sentinel-1 GRD imagery for earthquake, USGS SRTMGL1 imagery for Tsunami, MODIS/061/MCD64A1 for fire and COPERNICUS/S1_GRD for landslide satellite data are significant to the study.\n\n\n\nA robust methodology has been employed to achieve the aim of designing an application to assess the impact of multiple disaster events in a given spatial location in Japan. The first objective involves designing maps for individual disasters, such as earthquakes, tsunamis, fires, and landslides. Subsequently, the multi-disaster map depicts the intensity of disasters in terms of the number of events affecting the same building or area. This exercise aims to design an application to assess the impact of multiple disaster events in a given spatial location of the City of Wajima. The present design of the application attempts to achieve the following objectives:\n\nTo understand the intensity of the disaster in terms of the number/ level of disasters impacting building damage or spatial vulnerability.\nFinally, to develop a user interface application for the ease of information access and knowledge dissemination to stakeholders.\n\nThe various methods used are machine learning (ML) using Random Forest, NDVI/NIR, confusion matrix, T-Test, mean, standard deviation, confidence level, assumptions, standards. In addition, these objectives facilitate the development of an application for easy of access to information and dissemination of knowledge to users whose methodology is as below.\n\n\n\nMethodology\n\n\n\n\n\nCreating a user-friendly interactive platform, the multi-disaster application offers several advantages. The present application categorizes into sequential disaster maps of earthquakes, landslides, fires, and tsunamis, each equipped with layers, panels, buttons, sliders, etc., for user interaction. The earthquake map provides building damage visualization, allowing users to draw polygons to calculate the number of damaged buildings and shows damage assessment using a low-to-high scale based on t-test results. The landslide map visualizes occurrences of landslides and allows users to assess intensity by toggling between options such as pre-event, post-event, landslide detection, road, water bodies using the confusion matrix, and accuracy algorithm. Similarly, the fire disaster map illustrates the catchment area from the fire source, with layers based on brightness and surface temperature change for further interaction. Lastly, the tsunami disaster map displays building damage and flood level implications, allowing users to adjust the flood level slider to identify inundated buildings and area. Overall, the designed interface offers multi-disaster maps with various options for user interaction to assess location, building damage count, risk levels, pre-event/post-event scenarios, buffer zones, catchment areas, and more.Therefore, the outputs could be utilized by the user, i.e., identified stakeholders, to undertake building reconstruction, retrofitting, policy interventions, disaster mitigation, and management."
  },
  {
    "objectID": "index.html#the-application",
    "href": "index.html#the-application",
    "title": "CASA00025 : Comprehensive Multi-Disaster Application",
    "section": "",
    "text": "The following link to application is as below."
  },
  {
    "objectID": "index.html#how-it-works",
    "href": "index.html#how-it-works",
    "title": "CASA00025 : Comprehensive Multi-Disaster Application",
    "section": "",
    "text": "The provided JavaScript code defines a function ‘ttest’ for performing a t-test analysis on Sentinel-1 Synthetic Aperture Radar (SAR) imagery. The function takes inputs such as the image collection ‘s1’, shock date, pre-event and post-event intervals, and calculates the t-value representing the magnitude of change between the two periods. It computes the mean and standard deviation for both the pre-event and post-event periods, then calculates the pooled standard deviation and the denominator of the t-test formula. Finally, it returns the absolute value of the change, which indicates the significance of the difference between the two periods.\nAdditionally, there is another function ‘filter_s1’ that filters Sentinel-1 GRD (Ground Range Detected) imagery based on specified parameters such as orbit path, polarization, and date range. It aggregates the relative orbit numbers, then maps over each orbit to filter the image collection accordingly. Within this function, the ‘ttest’ function is applied to both VV and VH polarizations separately, and the resulting t-values are combined to form a mean t-value image. This allows for the analysis of change detection in SAR imagery over a specified time period and orbit path.\n-- ///\n// Set functions //\n// Define a t-test function\nfunction ttest(s1, shock, pre_interval, post_interval) {\n  \n  // Convert the shock date to a date object\n  var shock = ee.Date(shock);\n  // Filter the image collection to the pre-event period\n  var pre = s1.filterDate(\n    shock.advance(ee.Number(pre_interval).multiply(-1), \"month\"),\n    shock\n  );\n  // Filter the image collection to the post-event period\n  var post = s1.filterDate(shock, shock.advance(post_interval, \"month\"));\n  \n  // Calculate the mean, standard deviation, and number of images for the pre-event period\n  var pre_mean = pre.mean();\n  var pre_sd = pre.reduce(ee.Reducer.stdDev());\n  var pre_n = ee.Number(pre.aggregate_array('orbitNumber_start').distinct().size());\n  \n  // Calculate the mean, standard deviation, and number of images for the pre-event period\n  var post_mean = post.mean();\n  var post_sd = post.reduce(ee.Reducer.stdDev());\n  var post_n = ee.Number(post.aggregate_array('orbitNumber_start').distinct().size());\n  \n  // Calculate the pooled standard deviation\n  var pooled_sd = pre_sd\n    .multiply(pre_sd)\n    .multiply(pre_n.subtract(1))\n    .add(post_sd.multiply(post_sd).multiply(post_n.subtract(1)))\n    .divide(pre_n.add(post_n).subtract(2))\n    .sqrt();\n\n    // Calculate the denominator of the t-test\n  var denom = pooled_sd.multiply(\n    ee.Number(1).divide(pre_n).add(ee.Number(1).divide(post_n)).sqrt()\n  );\n\n    // Calculate the Degrees of Freedom, which is the number of observations minus 2\n  var df = pre_n.add(post_n).subtract(2);\n\n  \n  var change = post_mean\n  　.abs()\n    .subtract(pre_mean)\n    .divide(denom)\n    .abs() //returning abs, so as t-value is bigger, the change becomes bigger.\n    //.subtract(2);\n\n    // return the t-values for each pixel\n    return change\n}\n\n// Define a satelite image after t-test\nfunction filter_s1(path) {\n\n  // Filter the image collection to the ascending or descending orbit\n  var orbits = ee\n    .ImageCollection(\"COPERNICUS/S1_GRD_FLOAT\")\n    .filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VH\"))\n    .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))\n    .filter(ee.Filter.eq(\"orbitProperties_pass\", path))\n    .filterBounds(aoi)\n    .filterDate('2023-01-01','2024-04-15')\n    .aggregate_array('relativeOrbitNumber_start')\n    .distinct()\n  \n  print(orbits)\n  \n  var image_col=ee.ImageCollection(orbits.map(function(orbit){\n\n  var s1 = ee\n    .ImageCollection(\"COPERNICUS/S1_GRD_FLOAT\")\n    .filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VH\"))\n    .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))\n    .filter(ee.Filter.eq(\"relativeOrbitNumber_start\",orbit))\n  \n  \n  // Calculate the t-test for the filtered image collection using the function we defined earlier\n  var vv = ttest(s1.select(\"VV\"), \"2024-01-01\", 12, 4)\n  var vh = ttest(s1.select(\"VH\"), '2024-01-01', 12, 4)\n  var vv= vv.rename('change');\n  var vh= vh.rename('change');\n  \n    // Return the t-values for each pixel\n  var image=ee.ImageCollection([vv,vh]).mean()\n\n  return image\n  })).mean()\n  \n  return image_col\n    \n  }\n\n\n\n// Set a dates //\nvar start = \"2023-01-01\";\nvar now = Date.now();\n//var now='2024-03-31'\nvar end = ee.Date(now).format();\n\n\n\n// Set an interface //\n\n// Create a Draw a Polygon botton\nvar drawButton = ui.Button({\n  label: \"🔺\" + \" Draw a Polygon\",\n  onClick: drawPolygon,\n  style: { stretch: \"horizontal\" },\n});\n\n// Create a Damage Assesment panel\nvar footagePanel = ui.Panel({\n  widgets: [\n    ui.Label(\"Damage Assessment\", {\n      fontWeight: \"bold\",\n      fontSize: \"20px\",\n    }),\n    ui.Label(\n      \"Click the button below and draw a box on the map to get an estimate of the number of damaged buildings in a given area\",\n      { whiteSpace: \"wrap\" }\n    ),\n    \n    drawButton,\n    ui.Label(),\n  ],\n  style: { position: \"top-left\", maxWidth: \"350px\", maxHeight:'90%'},\n  layout: ui.Panel.Layout.flow(\"vertical\", true),\n});\n\n\n// Define a color scale function\nfunction makeColorBarParams(palette) {\n  return {\n    bbox: [0, 0, 1, 0.1],\n    dimensions: \"100x10\",\n    format: \"png\",\n    min: 0,\n    max: 1,\n    palette: palette.reverse(),\n  };\n}\nvar reds = [\"yellow\", \"red\", \"purple\"];\n\n// Create the color bar\nvar colorBar = ui.Thumbnail({\n  image: ee.Image.pixelLonLat().select(0),\n  params: makeColorBarParams(reds.reverse()),\n  style: { stretch: \"horizontal\", margin: \"0px 8px\", maxHeight: \"24px\" },\n});\n\n// Create the title for the color bar\nvar legendTitle = ui.Label({\n  value: \"Estimated Damage (t-value)\",\n  style: { fontWeight: \"bold\" ,textAlign: \"center\",stretch: \"horizontal\"},\n});\n\n// Create the panel for the color bar\nvar legendLabels = ui.Panel({\n  widgets: [\n    ui.Label('Low', { margin: \"4px 8px\" }),\n    ui.Label( \" \", {\n      margin: \"4px 8px\",\n      textAlign: \"center\",\n      stretch: \"horizontal\",\n    }),\n    ui.Label('High', { margin: \"4px 8px\" }),\n    ],\n  layout: ui.Panel.Layout.flow(\"horizontal\"),\n});\n\n// Create the scale\nvar scalePanel = ui.Panel({\n  widgets: [\n    ui.Label('2.5', { margin: \"4px 8px\" }), \n    ui.Label( \" \", {\n      margin: \"4px 8px\",\n      textAlign: \"center\",\n      stretch: \"horizontal\",\n    }),\n    ui.Label('6.0', { margin: \"4px 8px\" }), \n  ],\n  layout: ui.Panel.Layout.flow(\"horizontal\"),\n});\n\n// Set the panel \nvar legendPanel = ui.Panel({\n  widgets: [legendTitle, scalePanel, colorBar, legendLabels],\n  style: { position: \"bottom-left\", Width: \"350px\"},\n});\n\n\n\n// Apply for a Japan case //\n// Create mapPanel_building\nvar mapPanel_building = ui.Map();\nmapPanel_building.setOptions('SATELLITE');\n\n// Show mapPanel_building\nui.root.widgets().set(0, mapPanel_building);\n\n\n// Define a function for returning an image of damaged buildings\nfunction footprints(cutoff, aoi, label) {\n  var footprints = ee.FeatureCollection('projects/ee-rengeanzu/assets/location-points-to-polygonss')\n    .filterBounds(aoi)\n    .map(function(feat) {\n      return feat.set('area', feat.geometry().area(10)).set('geometry_type', feat.geometry().type());\n    })\n    .filter(ee.Filter.gt('area', 50));　//remove under 50 m2 buildings\n\n  var mean = image.reduceRegions({\n    collection: footprints,\n    reducer: ee.Reducer.mean(),\n    scale: 10\n  });\n  var damaged = mean.filter(ee.Filter.gt('mean', cutoff))\n\n  print(damaged.size())\n  \n  var totalCount = mean.size()\n  var damagedCount = damaged.size()\n  var proportion = ((damagedCount.divide(totalCount)).multiply(100)).int() // .evaluate(function(val){return val});\n\n\n  var outlines = ui.Map.Layer(damaged, {\n    color: 'red'\n  }, 'footprints');\n\n  mapPanel_building.layers().set(0, outlines)\n  mapPanel_building.layers().get(0).setShown(true)\n  mapPanel_building.layers().get(1).setShown(false)\n}\n\n\n// Define \"change\" layer\nfunction clear() {\n  // Define a clear map\n  mapPanel_building.clear()\n\n  mapPanel_building.setOptions('SATELLITE')\n  mapPanel_building.setControlVisibility({\n    all: false\n  });\n  mapPanel_building.setControlVisibility({\n    layerList: true,\n    mapTypeControl: true\n  }); \n\n  var urban = ee.ImageCollection('GOOGLE/DYNAMICWORLD/V1').filterDate('2023-01-01', '2024-04-15').mean().select('built')\n\n  var boxcar = ee.Kernel.gaussian({\n    radius: 50,\n    units: 'meters',\n    normalize: true,\n    sigma: 20\n  });\n\n  // Call the filter_s1 function once for each orbit, and then combine the two images into a single image\n  var asc = filter_s1(\"ASCENDING\")\n  var desc = filter_s1(\"DESCENDING\")\n\n  var image = ee\n    .ImageCollection([asc, desc]).mean().convolve(boxcar)\n    .updateMask(urban.gt(0.3))\n\n  // Add the composite to the map\n  var reds = [\"yellow\", \"red\", \"purple\"];\n\n  // Add the composite to the map\n  var damage_layer = ui.Map.Layer(\n    image.updateMask(image.gt(2.5)), {\n      min: 2.5,\n      max: 6,\n      opacity: 0.8,\n      palette: reds\n    },\n    \"change\"\n  );\n\n  mapPanel_building.layers().set(0, damage_layer)\n  mapPanel_building.style().set(\"cursor\", \"crosshair\");\n  mapPanel_building.centerObject(initialPoint, 14);\n  mapPanel_building.add(legendPanel);\n\n\n  return image\n}\n\n\n// Define a function to clear map and add a Damage Assesment panel\nfunction home() {\n  var image = clear()\n\n  mapPanel_building.add(footagePanel)\n  return image\n}\n\n\n// Define a Draw a Polygon button\nvar drawingTools = mapPanel_building.drawingTools();\n\ndrawingTools.setShown(false);\n\nwhile (drawingTools.layers().length() &gt; 0) {\n  var layer = drawingTools.layers().get(0);\n  drawingTools.layers().remove(layer);\n}\n\nvar dummyGeometry = ui.Map.GeometryLayer({ \n  geometries: null,\n  name: \"geometry\",\n  color: \"23cba7\",\n}).setShown(false);\n\ndrawingTools.layers().add(dummyGeometry)\n\nfunction clearGeometry() {\n  var layers = drawingTools.layers();\n  layers.get(0).geometries().remove(layers.get(0).geometries().get(0));\n}\n\nfunction drawPolygon() {\n  clearGeometry();\n  drawingTools.setShape(\"rectangle\");\n  drawingTools.draw();\n}\n\nfunction drawPoint() {\n  clearGeometry();\n  drawingTools.setShape(\"point\");\n  //var pointBuffer = point.buffer({'distance': 100});\n  drawingTools.draw();\n}\n\n\n// Run a footprints function\nfunction footprints() {\n  var aoi = drawingTools.layers().get(0).getEeObject();\n  drawingTools.layers().get(0).setShown(false);\n\n  var footprints = ee.FeatureCollection('projects/ee-rengeanzu/assets/location-points-to-polygons')\n    .filterBounds(aoi)\n    .map(function(feat) {\n      return feat.set('area', feat.geometry().area(10)).set('geometry_type', feat.geometry().type());\n\n    })\n    .filter(ee.Filter.gt('area', 50))\n    .filter(ee.Filter.equals('geometry_type', 'Polygon'));\n\n  var mean = image.reduceRegions({\n    collection: footprints,\n    reducer: ee.Reducer.mean(),\n    scale: 10\n  });\n  var damaged = mean.filter(ee.Filter.gt('mean', 1.96)) //95% confidence period\n\n  var totalCount = mean.size()\n  var damagedCount = damaged.size()\n  var proportion = ((damagedCount.divide(totalCount)).multiply(100)).int() // .evaluate(function(val){return val});\n\n  var sumLabel2 = ui.Label({\n    value: 'Calculating...'\n  })\n  var meanLabel2 = ui.Label({\n    value: 'Calculating...'\n  })\n\n  damagedCount.evaluate(function(val) {\n    sumLabel2.setValue(val)\n  });\n  proportion.evaluate(function(val) {\n    meanLabel2.setValue(val)\n  });\n\n  var sumLabel1 = ui.Label(\"Number of damaged buildings in the area: \")\n  var meanLabel1 = ui.Label(\"Proportion (%): \")\n\n  var sumPanel = ui.Panel({\n    layout: ui.Panel.Layout.flow('horizontal'),\n    widgets: [sumLabel1, sumLabel2]\n  })\n  var meanPanel = ui.Panel({\n    layout: ui.Panel.Layout.flow('horizontal'),\n    widgets: [meanLabel1, meanLabel2]\n  })\n\n  var statsPanel = ui.Panel([sumPanel, meanPanel])\n\n  footagePanel.widgets().set(4, statsPanel);\n\n  Export.table.toDrive({\n    collection: damaged,\n    description: '_damaged_buildings',\n  });\n\n  Export.image.toDrive({\n    image: image.clip(aoi),\n    scale: 10,\n    description: '_damage',\n  });\n\n  var outlines = ui.Map.Layer(damaged, {\n    color: 'red'\n  }, 'footprints');\n\n  mapPanel_building.layers().set(1, outlines)\n  mapPanel_building.layers().get(0).setShown(false)\n}\n\nvar image = home()\n\ndrawingTools.onDraw(footprints);\n\nmapPanel_building.add(buttonPanel);\n\n\n\nPixelwise T-Test, 2023-24\n\n\nand math: \\[ \\Large t = {\\frac{\\overline{x_1}-\\overline{x_2}} {\\sqrt{\\frac{s^2_1}{n_1} + \\frac{s^2_2}{n_2}}}} \\]\n\n\n\nThe code snippet provides a landslide detection visualization tool using Sentinel-1 GRD imagery. It calculates the mean difference between pre and post-event periods, applying a threshold to create a mask highlighting areas of significant change. The masked layer, showing the difference more clearly, is overlaid on the map along with the original landslide detection layer, enabling users to visualize and assess potential landslide areas effectively.\nTo enhance the analysis, additional features such as building footprints or vegetation indices like NDVI/NIR could be integrated. Clipping the analysis to land areas using multipoint geometry could provide more accurate results. Adjusting the threshold for the mask can improve the display by focusing on areas with substantial changes, aiding in the identification and assessment of landslide risks. Users can interact with the map interface to explore different layers and adjust parameters for more comprehensive landslide detection and visualization.\n// Set up the Area of Interest (AOI)\nvar point = ee.Geometry.Point([136.89961, 37.39405]); // Center point\nvar aoi = point.buffer(10000); // 10 km buffer around the point\n\n// Define the time range for pre- and post-event analysis\nvar preStart = '2023-08-01';\nvar preEnd = '2023-12-31';\nvar postStart = '2024-01-02';\nvar postEnd = '2024-03-31';\n\n// Load the Sentinel-2 Image Collection within the specified dates and area\nvar s2 = ee.ImageCollection('COPERNICUS/S2')\n          .filterBounds(aoi)\n          .filterDate(preStart, postEnd)\n          .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10));\n\n// Function to calculate NDVI\nfunction addNDVI(image) {\n  var ndvi = image.normalizedDifference(['B8', 'B4']).rename('NDVI');\n  return image.addBands(ndvi);\n}\n\n// Apply the NDVI function to each image in the collection\nvar ndviCollection = s2.map(addNDVI);\n\n// Compute median NDVI images for pre and post periods\nvar preNDVI = ndviCollection.filterDate(preStart, preEnd).median().select('NDVI');\nvar postNDVI = ndviCollection.filterDate(postStart, postEnd).median().select('NDVI');\n\n// Calculate NDVI difference to highlight changes\nvar ndviDiff = postNDVI.subtract(preNDVI).rename('NDVI_Diff');\n// Calculate NDVI difference\nvar ndviDifference = postNDVI.subtract(preNDVI);\n\n// Sampling points for training\n// Assume points are pre-classified as 1 (landslide) or 0 (no landslide)\nvar points = ee.FeatureCollection([\n    ee.Feature(ee.Geometry.Point([137.1018965847964,37.45891870504624]), {label: 1}),\n    ee.Feature(ee.Geometry.Point([136.8232291924816,37.34724623299005]), {label: 0})\n]);\n\n// Overlay the points on the NDVI difference to extract training data\nvar training = ndviDifference.sampleRegions({\n    collection: points,\n    properties: ['label'],\n    scale: 10\n});\n\n// Train a Random Forest classifier\nvar classifier = ee.Classifier.smileRandomForest(50).train({\n    features: training,\n    classProperty: 'label',\n    inputProperties: ['NDVI']\n});\n\n// Apply the classifier to the NDVI difference image\nvar classified = ndviDifference.classify(classifier);\n\n// Visualize clusters\n\n// Load and filter additional datasets for roads and water bodies\nvar roads = ee.FeatureCollection('TIGER/2016/Roads').filterBounds(aoi);\nvar waterBodies = ee.FeatureCollection('HYCOM/sea_water_velocity');\n//var buildings = ee.FeatureCollection('GlobalHumanSettlementLayer/GHS_BUILT_LDSMT_GLOBE_V1').filterBounds(aoi);\n\n\n// Visualization parameters\nvar visParams = {\n  bands: ['NDVI_Diff'],\n  min: -0.5,\n  max: 0.5,\n  palette: ['blue', 'white', 'red']\n};\n\nvar roadParams = {\n  color: 'yellow',\n  width: 1\n};\n\nvar waterParams = {\n  color: 'blue',\n  width: 1\n};\n//var clusterVis = {min: 0, max: 2, palette: ['cyan', 'orange', 'purple']};\n// Adding layers to the Map\n\n// Create a map layer control panel.\nvar panel = ui.Panel({style: {width: '300px'}});\nvar mapPanel_landslide = ui.Map();\nmapPanel_landslide.centerObject(initialPoint, 14);\nmapPanel_landslide.setOptions(\"SATELLITE\");\n// Add layers to the map.\nmapPanel_landslide.add(ui.Map.Layer(preNDVI.select('NDVI'), {min: -1, max: 1, palette: ['blue', 'white', 'green']}, 'Pre-event NDVI', false));\nmapPanel_landslide.add(ui.Map.Layer(postNDVI.select('NDVI'), {min: -1, max: 1, palette: ['blue', 'white', 'green']}, 'Post-event NDVI', false));\nmapPanel_landslide.add(ui.Map.Layer(ndviDiff, visParams, 'NDVI Difference', false));\nmapPanel_landslide.add(ui.Map.Layer(classified, {min: 0, max: 1, palette: ['blue', 'red'], opacity: 0.5}, 'Landslide Prediction', true));\nmapPanel_landslide.add(ui.Map.Layer(roads.style(roadParams), {}, 'Roads', false));\nmapPanel_landslide.add(ui.Map.Layer(waterBodies.style(waterParams), {}, 'Water Bodies', false));\n\n// Create checkbox widgets for layer visibility.\nvar checkbox1 = ui.Checkbox('Show Pre-event NDVI', false, function(checked) {\n  mapPanel_landslide.layers().get(0).setShown(checked);\n});\nvar checkbox2 = ui.Checkbox('Show Post-event NDVI', false, function(checked) {\n  mapPanel_landslide.layers().get(1).setShown(checked);\n});\nvar checkbox3 = ui.Checkbox('Show NDVI Difference', false, function(checked) {\n  mapPanel_landslide.layers().get(2).setShown(checked);\n});\nvar checkbox4 = ui.Checkbox('Show Landslide Detection', true, function(checked) {\n  mapPanel_landslide.layers().get(3).setShown(checked);\n  \n});\nvar checkbox5 = ui.Checkbox('Show Roads', false, function(checked) {\n  mapPanel_landslide.layers().get(4).setShown(checked);\n});\nvar checkbox6 = ui.Checkbox('Show Water Bodies', false, function(checked) {\n  mapPanel_landslide.layers().get(5).setShown(checked);\n});\n\nvar title = ui.Label('Classifier Details', {fontWeight: 'bold'});\npanel.add(title);\nvar validation = classified.sampleRegions({\n  collection: points,\n  properties: ['label'],\n  scale: 10,\n});\n\nvar confusionMatrix = validation.errorMatrix('label', 'classification');\n\n// Add confusion matrix and accuracy to the panel\nvar matrixLabel = ui.Label('Confusion Matrix:');\nvar matrixValue = ui.Label(confusionMatrix.array().getInfo());\npanel.add(matrixLabel);\npanel.add(matrixValue);\n\nvar accuracyLabel = ui.Label('Overall Accuracy:');\nvar accuracyValue = ui.Label(confusionMatrix.accuracy().getInfo());\npanel.add(accuracyLabel);\npanel.add(accuracyValue);\n// Function to create and style the legend\nfunction createLegend() {\n  var legend = ui.Panel({\n    style: {\n      position: 'bottom-left',\n      padding: '8px 15px'\n    }\n  });\n\n  // Create legend title\n  var legendTitle = ui.Label({\n    value: 'Landslide prediction',\n    style: {\n      fontWeight: 'bold',\n      fontSize: '18px',\n      margin: '0 0 4px 0',\n      padding: '0'\n    }\n  });\n\n  // Add the title to the legend\n  legend.add(legendTitle);\n\n  // Set legend keys and descriptions\n  var names = ['No landslide - Blue', 'Landslide - Red'];\n  var colors = ['blue', 'red']; // These should match 'palette' in visParams\n\n  // Add color boxes and labels to the legend\n  for (var i = 0; i &lt; names.length; i++) {\n    var colorBox = ui.Label({\n      style: {\n        backgroundColor: colors[i],\n        // Make sure the color box is square\n        padding: '8px',\n        margin: '0 0 4px 0'\n      }\n    });\n\n    var description = ui.Label({\n      value: names[i],\n      style: {margin: '0 0 4px 6px'}\n    });\n\n    // Make a horizontal panel to hold the color box and description\n    var colorPanel = ui.Panel({\n      widgets: [colorBox, description],\n      layout: ui.Panel.Layout.Flow('horizontal')\n    });\n\n    // Add the color panel to the legend\n    legend.add(colorPanel);\n  }\n\n  return legend;\n}\n\n// Create the legend\nvar legend = createLegend();\n\n// Create a checkbox to toggle the legend's visibility\nvar checkbox = ui.Checkbox('Landslide prediction Legend', true, function(checked) {\n  // Show or hide the legend based on the checkbox\n  legend.style().set('shown', checked);\n});\n\n// Add the checkbox and the legend to the UI\npanel.add(checkbox);\nmapPanel_landslide.add(legend);\n\n// Add the widgets to the panel and add the panel to the map.\npanel.add(checkbox1);\npanel.add(checkbox2);\npanel.add(checkbox3);\npanel.add(checkbox4);\npanel.add(checkbox5);\npanel.add(checkbox6);\nmapPanel_landslide.add(panel);\n\n// Add the map to the UI.\n//ui.root.add(map);\n\n\n\nMachine Learning (Random Forest Analysis), 2024\n\n\n\n\n\nThe code snippet creates a fire burn area visualization tool in Earth Engine’s JavaScript API. It allows users to select different fire datasets and years using dropdown menus and sliders, respectively. Upon selection, the map dynamically updates to display the burned areas for the chosen dataset and year, aiding in the assessment and monitoring of fire impacts over time and across different datasets.\nvar mapPanel_fire = ui.Map();\nmapPanel_fire.centerObject(initialPoint, 14);\nmapPanel_fire.setOptions(\"satellite\");\n\n\nvar footprints_fire = ee.FeatureCollection('projects/ee-rengeanzu/assets/location-points-to-polygons')\n  .filterBounds(aoi)\n  .map(function(feat) {\n    return feat.set('area', feat.geometry().area(10)).set('geometry_type', feat.geometry().type());\n  })\n  .filter(ee.Filter.gt('area', 50))\n  .filter(ee.Filter.equals('geometry_type', 'Polygon'));\n\nvar mean = image.reduceRegions({\n  collection: footprints_fire,\n  reducer: ee.Reducer.mean(),\n  scale: 10\n});\n\n\n\nvar empty_fire = ee.Image().byte();\n\n// Paint the building footprints onto the empty image\nvar outline_fire = empty_fire.paint({ \n  featureCollection: mean.filter(ee.Filter.gt('mean', 2.5)),\n  color: \"mean\",\n  width: 1,\n});\n\n// Dilate the painted areas to make the outline thicker\nvar dilated_outline_fire = outline_fire.focal_max({ radius: 3, kernelType: 'circle', iterations: 1 });\n\n// Define a color palette\nvar building_palette_fire = [\n  '70db70', 'ff9933', '7500fa'\n];\n\n// Add the image to the map\nmapPanel_fire.addLayer(\n  dilated_outline_fire,\n  { min: 2.5,\n    max: 6,\n    palette: building_palette_fire,\n    opacity: 0.8 },\n  \"Damaged Buildings for Fire\"\n);\n\n\n\n// // fire data layer\nvar firePoints = ee.FeatureCollection('projects/ee-rengeanzu/assets/df1_filter');\n\n\n// Generate an impact circle area for each fire spot\nvar radii = [15, 50, 100];  // The unit is meters\nvar fireBuffers = firePoints.map(function(feature) {\n  var buffers = ee.FeatureCollection(radii.map(function(radius) {\n    return feature.buffer(radius).set('radius', radius); \n  }));\n  return buffers;\n}).flatten();\n// Setting the display colors for different radii\nvar colors = ['FF0000'];\nvar opacities = ['44', '88', 'FF'];  \nvar styledBuffers = fireBuffers.map(function(feature) {\n  // Retrieve the 'radius' property of the feature, set a default if undefined\n  var radius = feature.get('radius') || 10;  \n  var idx = radii.indexOf(radius);  \n\n  // Use default index if idx is invalid\n  if (idx === -1 || idx === undefined) {\n    idx = 0;  // Use a safe default index\n  }\n\n  // Use valid colors and opacities, or use default values\n  var color = colors[idx] || 'FF0000';  \n  var opacity = opacities[idx] || 'FF'; \n  var fillColor = color + opacity; \n\n  // Define the style\n  var style = {\n    color: color,\n    fillColor: fillColor,\n    fillOpacity: 0.5  // Set fill opacity\n  };\n\n  // Apply the style\n  return feature.set('style', style);\n});\n\n// Display the buffer zones on the map\nmapPanel_fire.addLayer(styledBuffers.style({styleProperty: 'style'}), {}, 'Impact Zones');\n\n\n// Create a panel to hold labels and a legend\nvar panel_fire = ui.Panel({\n  style: {\n    width: '300px',\n    padding: '8px',\n    position: \"top-left\"\n  }\n});\n\n// Create labels to explain the layers\nvar introLabel = ui.Label({\n  value: 'Map Layer Explanation',\n  style: {fontWeight: 'bold', fontSize: '16px', margin: '0 0 4px 0'}\n});\n\nvar fireLabel = ui.Label({\n  value: 'Fire Impact Zones: Circles of different colors and radii represent varying levels of fire impact.',\n  style: {fontSize: '12px', margin: '0 0 4px 0'}\n});\n\nvar damageLabel = ui.Label({\n  value: 'Damaged Buildings: Different colors indicate the degree of damage to buildings.',\n  style: {fontSize: '12px', margin: '0 0 4px 0'}\n});\n\n// Add labels to the panel\npanel_fire.add(introLabel);\npanel_fire.add(fireLabel);\npanel_fire.add(damageLabel);\n\n// Define a function to create a color legend\nfunction createLegendItem(color, description) {\n  var colorBox = ui.Label({\n    style: {\n      backgroundColor: '#' + color,\n      // Ensure proper size of the color box\n      padding: '8px',\n      margin: '0 8px 4px 0'\n    }\n  });\n\n  var descriptionLabel = ui.Label({\n    value: description,\n    style: {margin: '0 0 4px 6px'}\n  });\n\n  return ui.Panel({\n    widgets: [colorBox, descriptionLabel],\n    layout: ui.Panel.Layout.Flow('horizontal')\n  });\n}\n\n// Add a legend title to the panel\nvar legendTitle = ui.Label({\n  value: 'Legend',\n  style: {fontWeight: 'bold', fontSize: '14px', margin: '8px 0 4px 0'}\n});\npanel_fire.add(legendTitle);\n\n// Add specific color legend items\nvar colors = ['70db70', 'ff9933', '7500fa'];\nvar descriptions = [\n  'Minor damage - Light green',\n  'Moderate damage - Yellow',\n  'Critical damage - Deep purple'\n];\n\ncolors.forEach(function(color, index) {\n  panel_fire.add(createLegendItem(color, descriptions[index]));\n});\n\n\n\nMachine Learning (Random Forest Analysis), 2024\n\n\n\n\n\nThe provided JavaScript code is a Google Earth Engine script designed to simulate the inundation of buildings caused by a tsunami event. It utilizes elevation data from the USGS SRTMGL1 dataset to determine flooded areas at various water levels. The script loads a CSV file containing building footprints and iterates over different flood levels, displaying the impacted buildings on a map. It distinguishes flooded buildings at different water levels using different colors and provides a legend panel to explain the color scheme.\nThe script initializes a map panel centred on a specific location and loads elevation data and building footprints within a defined area of interest. It then computes and visualizes the affected buildings at different flood levels, allowing for the assessment of tsunami inundation impact on infrastructure. Additionally, it constructs a legend panel to provide a clear explanation of the color-coded representation of flooded buildings at various water levels, enhancing the interpretability of the map visualization.\n\n  /// ------------------------------------- AREA ------------------------------------- ///\n\n// Create a mappanel for tsunami area\nvar mapPanel_tsunami = ui.Map();\nmapPanel_tsunami.centerObject(initialPoint, 14);\nmapPanel_tsunami.setOptions(\"SATELLITE\");\n\n// Load the elevation data\nvar elevation = ee.Image('USGS/SRTMGL1_003').clip(aoi);\n\nvar bluePalette = [\n    '#00008B',   // Dark blue\n    '#333399',   // Darker blue\n    '#666699',   // Even darker blue\n    '#9999CC',   // Slightly lighter blue\n    '#CCCCFF',   // Light blue\n    '#FFFFCC',   // Lightest yellow\n];\n\n// Variable to store the previous flooded area\nvar previousFlooded = ee.Image.constant(0).clip(aoi);\n\n// Iterate over different flood levels\n[1, 3, 5, 7, 9, 11].forEach(function(level, index) {\n    // Compute the flooded area at the current water level\n    var currentFlooded = elevation.lte(level);\n\n    // Exclude areas affected by previous water levels\n    var newFloodedArea = currentFlooded.and(previousFlooded.not());\n\n    // Update the previously flooded area\n    previousFlooded = previousFlooded.or(currentFlooded);\n\n    var visualization = {\n        palette: [bluePalette[index]],\n        min: 0,\n        max: 1,\n        opacity: 0.5\n    };\n\n    // Visualize the newly flooded area at the current water level\n    mapPanel_tsunami.addLayer(newFloodedArea.updateMask(newFloodedArea), visualization, 'Flooded at ' + level + 'm');\n});\n\n// Create a panel to display layer annotations\nvar legend_tsunami = ui.Panel({\n    style: {\n        position: 'bottom-left',\n        padding: '8px 15px'\n    }\n});\n\n// Add a title for layer annotations\nvar legendTitle_tsunami = ui.Label({\n    value: 'Layer Description',\n    style: {\n        fontWeight: 'bold',\n        fontSize: '18px',\n        margin: '0 0 4px 0',\n        padding: '0'\n    }\n});\nlegend_tsunami.add(legendTitle_tsunami);\n\nvar layers = [\n    {name: 'Flooded at 1m', color: bluePalette[0]},\n    {name: 'Flooded at 3m', color: bluePalette[1]},\n    {name: 'Flooded at 5m', color: bluePalette[2]},\n    {name: 'Flooded at 7m', color: bluePalette[3]},\n    {name: 'Flooded at 9m', color: bluePalette[4]},\n    {name: 'Flooded at 11m', color: bluePalette[5]},\n];\n\nlayers.forEach(function(layer) {\n    // Create a panel with a horizontal layout\n    var layerItem = ui.Panel({\n        widgets: [\n            ui.Label({\n                value: '■', // Use a square symbol for the color block\n                style: {\n                    color: layer.color, // Set the color of the color block\n                    fontWeight: 'bold',\n                    fontSize: '18px', // Adjust size to fit annotation\n                    margin: '0 4px 0 0' // Right margin to separate color block and text\n                }\n            }),\n            ui.Label({\n                value: layer.name,\n                style: {\n                    color: 'black', // Text color\n                    margin: '0',\n                    fontSize: '16px' // Text size\n                }\n            })\n        ],\n        layout: ui.Panel.Layout.flow('horizontal')\n    });\n    // Add the annotation for each layer to the legend panel\n    legend_tsunami.add(layerItem);\n});\n\nvar tsunamiLabel = ui.Label('Simulation of tsunami inudation', \n{position: 'top-left', fontWeight: 'bold', fontSize: '24px'});\n mapPanel_tsunami.add(tsunamiLabel);\n  mapPanel_tsunami.add(legend_tsunami);\n  \n  \n  /// ------------------------------------- BUILDINGS ------------------------------------- ///\nvar mapPanel_tsunami2 = ui.Map();\nmapPanel_tsunami2.centerObject(initialPoint, 14);\nmapPanel_tsunami2.setOptions(\"SATELLITE\");\n\n// Define the area of interest (AOI) as a buffer of 3 kilometers around the center point\nvar aoi = ee.Geometry.Point(136.89961, 37.39405).buffer(3000);\n\n// Load the elevation data\nvar elevation = ee.Image('USGS/SRTMGL1_003').clip(aoi);\n\n// Load the CSV file containing building footprints\n// var csv = ee.FeatureCollection('projects/ee-rengeanzu/assets/202312BuildingFootprints').filterBounds(aoi);\n\n// Define an array of flood levels\nvar floodLevels = ee.List.sequence(1, 11);\n\n// Create a slider\nvar floodSlider = ui.Slider({\n  min: 1,\n  max: 11,\n  value: 1,\n  step: 1,\n  style: {stretch: 'horizontal'}\n});\n\n// Create a label to display the count\nvar countLabel = ui.Label('');\nvar label = ui.Label('Select flood level (meters):');\n\n// Create a panel containing the label, slider, and count\nvar panel = ui.Panel({\n  widgets: [label, floodSlider, countLabel],\n  style: {\n    position: 'bottom-left',\n    padding: '8px 15px'\n  }\n});\n\nmapPanel_tsunami2.add(panel);\n\n\nvar buildings = ee\n   .FeatureCollection(\"projects/ee-rengeanzu/assets/202312BuildingFootprints\")\n   .filterBounds(aoi);\n\n// Function to compute and display the impact of flooding at a specific water level\nfunction displayFloodImpact(floodLevel) {\n    // Flooded area at the current water level\n    var flooded = elevation.lte(floodLevel);\n    var floodedPoints = buildings.map(function(feature) {\n        return feature.set('isFlooded', flooded.reduceRegion({\n            reducer: ee.Reducer.anyNonZero(),\n            geometry: feature.geometry(),\n            scale: 30\n        }).get('elevation'));\n    }).filter(ee.Filter.eq('isFlooded', 1));\n\n    // Update the map layer and count\n    floodedPoints.size().evaluate(function(size) {\n        countLabel.setValue('Number of flooded buildings: ' + size);\n    });\n\n    // Visualize flooded buildings\n    var floodLayer = ui.Map.Layer(floodedPoints, {color: 'red'}, 'Flooded Buildings at ' + floodLevel + 'm', true, 0.6);\n    mapPanel_tsunami2.layers().set(0, floodLayer);\n}\n\n// Listen to slider changes\nfloodSlider.onSlide(function(value) {\n    displayFloodImpact(value);\n});\n\n// Initialize display\ndisplayFloodImpact(1);\n\n// Add a title\nmapPanel_tsunami2.add(ui.Label('The number of buildings estimated to be flooded', {position: 'top-left', fontWeight: 'bold', fontSize: '24px'}));\n\n\nvar mapPanel_tsunami = ui.Map();\nmapPanel_tsunami.centerObject(initialPoint, 14);\nmapPanel_tsunami.setOptions(\"SATELLITE\");\n\n// Load the elevation data\nvar elevation = ee.Image('USGS/SRTMGL1_003').clip(aoi);\n\n// Load the CSV file containing building footprints\n// var csv = ee.FeatureCollection('projects/ee-rengeanzu/assets/202312BuildingFootprints').filterBounds(aoi);\n\nvar bluePalette = [\n    '#00008B',  // Dark blue\n    '#0000CD',  // Medium blue\n    '#4169E1',  // Royal blue\n    '#FFA500',\n    '#FFD700', // Gold\n    '#FFFF00',  // Yellow\n];\n\n// Variable to store the previous flooded area\nvar previousFlooded = ee.Image.constant(0).clip(aoi);\n\n// Iterate over different flood levels\n[1, 3, 5, 7, 9, 11].forEach(function(level, index) {\n    // Compute the flooded area at the current water level\n    var currentFlooded = elevation.lte(level);\n\n    // Exclude areas affected by previous water levels\n    var newFloodedArea = currentFlooded.and(previousFlooded.not());\n\n    // Update the previously flooded area\n    previousFlooded = previousFlooded.or(currentFlooded);\n\n    var visualization = {\n        palette: [bluePalette[index]],\n        min: 0,\n        max: 1,\n        opacity: 0.5\n    };\n\n    // Visualize the newly flooded area at the current water level\n    mapPanel_tsunami.addLayer(newFloodedArea.updateMask(newFloodedArea), visualization, 'Flooded at ' + level + 'm');\n});\n\n// Create a panel to display layer annotations\nvar legend_tsunami = ui.Panel({\n    style: {\n        position: 'bottom-left',\n        padding: '8px 15px'\n    }\n});\n\n// Add a title for layer annotations\nvar legendTitle_tsunami = ui.Label({\n    value: 'Layer Description',\n    style: {\n        fontWeight: 'bold',\n        fontSize: '18px',\n        margin: '0 0 4px 0',\n        padding: '0'\n    }\n});\nlegend_tsunami.add(legendTitle_tsunami);\n\nvar layers = [\n    {name: 'Flooded at 1m', color: bluePalette[0]},\n    {name: 'Flooded at 3m', color: bluePalette[1]},\n    {name: 'Flooded at 5m', color: bluePalette[2]},\n    {name: 'Flooded at 7m', color: bluePalette[3]},\n    {name: 'Flooded at 9m', color: bluePalette[4]},\n    {name: 'Flooded at 11m', color: bluePalette[5]},\n];\n\nlayers.forEach(function(layer) {\n    // Create a panel with a horizontal layout\n    var layerItem = ui.Panel({\n        widgets: [\n            ui.Label({\n                value: '■', // Use a square symbol for the color block\n                style: {\n                    color: layer.color, // Set the color of the color block\n                    fontWeight: 'bold',\n                    fontSize: '18px', // Adjust size to fit annotation\n                    margin: '0 4px 0 0' // Right margin to separate color block and text\n                }\n            }),\n            ui.Label({\n                value: layer.name,\n                style: {\n                    color: 'black', // Text color\n                    margin: '0',\n                    fontSize: '16px' // Text size\n                }\n            })\n        ],\n        layout: ui.Panel.Layout.flow('horizontal')\n    });\n    // Add the annotation for each layer to the legend panel\n    legend_tsunami.add(layerItem);\n});\n\nvar tsunamiLabel = ui.Label('Simulation of tsunami inundation on City of Wajima', \n{position: 'top-left', fontWeight: 'bold', fontSize: '24px'});\n mapPanel_tsunami.add(tsunamiLabel);\n  mapPanel_tsunami.add(legend_tsunami);\n  \n  \n  var mapPanelLayout = ui.Panel({\n  widgets: [\n    mapPanel_tsunami,\n    mapPanel_tsunami2\n  ],\n  layout: ui.Panel.Layout.flow('horizontal'), // Arrange panels horizontally\n  style: { width: '100%', stretch: \"horizontal\" } })// Set panel size;\n\n\n\nAssumptions: Flood levels, 2024"
  },
  {
    "objectID": "readme.html",
    "href": "readme.html",
    "title": "",
    "section": "",
    "text": "Use this repository to host a website for your CASA0025 final project by following these stpes:\n\nclone this repository\ninstall quarto\nedit the ‘index.qmd’ file with the contents of your project\nusing terminal, navigate to the project directory and run “quarto render”\npush the changes to your github repository\non github, navigate to Settings&gt;Pages&gt;Build and Deployment. Make sure that under “Source” it says “deploy from branch”. Under “Branch”, select “Main” in the first dropdown and “Docs” under the second drop down. Then press “Save”\n\nYour website should now be available under https://{your_username}.github.io/{your_repo_name}"
  },
  {
    "objectID": "index.html#validation",
    "href": "index.html#validation",
    "title": "CASA00025 : Comprehensive Multi-Disaster Application",
    "section": "",
    "text": "One may witness the change from before and after building damage representing the pre-disaster and post-disaster."
  }
]